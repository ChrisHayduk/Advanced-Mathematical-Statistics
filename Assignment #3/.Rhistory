qq_matrix
#Output plot
ggplot(qq_matrix, aes(standard_normal_quantiles, transformed_x_1)) +
geom_point(size=3) +
geom_smooth(method='lm', se=F) +
xlab("Theoretical Quantiles") +
ylab("Ordered Data") +
ggtitle(TeX('Q-Q Plot for $x_1$')) +
theme.info
#Create vector of x_2 values
x_2 <- c(18.95, 19.00, 17.95, 15.54, 14.00, 12.95, 8.94, 7.49, 6.00, 3.99)
#Find lambda value
lambda_final <- box_cox(x_2, lambda, n)
lambda_final
#Transform x_2 using this lambda value
transformed_x_2 <- x_2^lambda_final
transformed_x_2 <- sort(transformed_x_2)
#Calculate the quantiles for the actual data
prob_levels <- ((1:n)-0.5)/n
#Calculate the theoretical normal quantiles
standard_normal_quantiles <- qnorm(prob_levels)
#Round the theoretical quantiles to 2 decimal places
standard_normal_quantiles <- round(standard_normal_quantiles,
digits = 2)
#Create matrix of values
qq_matrix <- as.data.frame(cbind(transformed_x_2, prob_levels,
standard_normal_quantiles))
#Print matrix
qq_matrix
#Output plot
ggplot(qq_matrix2, aes(standard_normal_quantiles, transformed_x_2)) +
geom_point(size=3) +
geom_smooth(method='lm', se=F) +
xlab("Theoretical Quantiles") +
ylab("Ordered Data") +
ggtitle(TeX('Q-Q Plot for $x_2$')) +
theme.info
#Create vector of x_2 values
x_2 <- c(18.95, 19.00, 17.95, 15.54, 14.00, 12.95, 8.94, 7.49, 6.00, 3.99)
#Find lambda value
lambda_final <- box_cox(x_2, lambda, n)
lambda_final
#Transform x_2 using this lambda value
transformed_x_2 <- x_2^lambda_final
transformed_x_2 <- sort(transformed_x_2)
#Calculate the quantiles for the actual data
prob_levels <- ((1:n)-0.5)/n
#Calculate the theoretical normal quantiles
standard_normal_quantiles <- qnorm(prob_levels)
#Round the theoretical quantiles to 2 decimal places
standard_normal_quantiles <- round(standard_normal_quantiles,
digits = 2)
#Create matrix of values
qq_matrix <- as.data.frame(cbind(transformed_x_2, prob_levels,
standard_normal_quantiles))
#Print matrix
qq_matrix
#Output plot
ggplot(qq_matrix, aes(standard_normal_quantiles, transformed_x_2)) +
geom_point(size=3) +
geom_smooth(method='lm', se=F) +
xlab("Theoretical Quantiles") +
ylab("Ordered Data") +
ggtitle(TeX('Q-Q Plot for $x_2$')) +
theme.info
#Create vector of x_1 values
x_1 <- c(1, 2, 3, 3, 4, 5, 6, 8, 9, 11)
#Find lambda value
lambda_final <- box_cox(x_1, lambda, n)
lambda_final
#Transform x_1 using this lambda value
transformed_x_1 <- (x_1^lambda_final - 1)/lambda_final
transformed_x_1 <- sort(transformed_x_1)
#Calculate the quantiles for the actual data
prob_levels <- ((1:n)-0.5)/n
#Calculate the theoretical normal quantiles
standard_normal_quantiles <- qnorm(prob_levels)
#Round the theoretical quantiles to 2 decimal places
standard_normal_quantiles <- round(standard_normal_quantiles,
digits = 2)
#Create matrix of values
qq_matrix <- as.data.frame(cbind(transformed_x_1, prob_levels,
standard_normal_quantiles))
#Print matrix
qq_matrix
#Output plot
ggplot(qq_matrix, aes(standard_normal_quantiles, transformed_x_1)) +
geom_point(size=3) +
geom_smooth(method='lm', se=F) +
xlab("Theoretical Quantiles") +
ylab("Ordered Data") +
ggtitle(TeX('Q-Q Plot for $x_1$')) +
theme.info
#Create vector of x_2 values
x_2 <- c(18.95, 19.00, 17.95, 15.54, 14.00, 12.95, 8.94, 7.49, 6.00, 3.99)
#Find lambda value
lambda_final <- box_cox(x_2, lambda, n)
lambda_final
#Transform x_2 using this lambda value
transformed_x_2 <- (x_2^lambda_final - 1)/lambda_final
transformed_x_2 <- sort(transformed_x_2)
#Calculate the quantiles for the actual data
prob_levels <- ((1:n)-0.5)/n
#Calculate the theoretical normal quantiles
standard_normal_quantiles <- qnorm(prob_levels)
#Round the theoretical quantiles to 2 decimal places
standard_normal_quantiles <- round(standard_normal_quantiles,
digits = 2)
#Create matrix of values
qq_matrix <- as.data.frame(cbind(transformed_x_2, prob_levels,
standard_normal_quantiles))
#Print matrix
qq_matrix
#Output plot
ggplot(qq_matrix, aes(standard_normal_quantiles, transformed_x_2)) +
geom_point(size=3) +
geom_smooth(method='lm', se=F) +
xlab("Theoretical Quantiles") +
ylab("Ordered Data") +
ggtitle(TeX('Q-Q Plot for $x_2$')) +
theme.info
box_cox <- function(data, lambda, n){
#Create vector to store values for l of lambda
l_of_lambda <- rep(-100, times = length(lambda))
#For loop to calculate l of lambda
for(i in 1:length(lambda)){
#Check if lambda is equal to 0
if(lambda[i] != 0){
y <- (data^(lambda[i]) - 1)/lambda[i]
} else{
y <- log(data)
}
#Calculate mean of transformed x_1 values
y_bar <- mean(y)
#Calculate value for l of lambda function and store it in the vector
l_of_lambda[i] <- (-n/2)*log((1/n) * sum((y - y_bar)^2)) +
(lambda[i] - 1) * sum(log(data))
}
#Find the lambda value that corresponds to the max value of l of lambda
lambda_final <- lambda[which.max(l_of_lambda)]
return(lambda_final)
}
#Create vector of x_1 values
x_1 <- c(1, 2, 3, 3, 4, 5, 6, 8, 9, 11)
#Find lambda value
lambda_final <- box_cox(x_1, lambda, n)
lambda_final
#Transform x_1 using this lambda value
transformed_x_1 <- (x_1^lambda_final - 1)/lambda_final
transformed_x_1 <- sort(transformed_x_1)
#Calculate the quantiles for the actual data
prob_levels <- ((1:n)-0.5)/n
#Calculate the theoretical normal quantiles
standard_normal_quantiles <- qnorm(prob_levels)
#Round the theoretical quantiles to 2 decimal places
standard_normal_quantiles <- round(standard_normal_quantiles,
digits = 2)
#Create matrix of values
qq_matrix <- as.data.frame(cbind(transformed_x_1, prob_levels,
standard_normal_quantiles))
#Print matrix
qq_matrix
#Output plot
ggplot(qq_matrix, aes(standard_normal_quantiles, transformed_x_1)) +
geom_point(size=3) +
geom_smooth(method='lm', se=F) +
xlab("Theoretical Quantiles") +
ylab("Ordered Data") +
ggtitle(TeX('Q-Q Plot for $x_1$')) +
theme.info
lambda_1 <- seq(0, 1.00, len = 100)
lambda_2 <- seq(0.5, 1.5, len = 100)
lambda_1[lambda_1 == 0.37]
lambda_1 <- seq(0.1, 1.00, len = 100)
lambda_1 <- seq(0., 1.00, len = 100)
lambda_1 <- seq(0, 1.00, len = 100)
lambda_2[lambda_2==0.94]
lambda_2
lambda_start <- c(0.37, 0.94)
lambda_1 <- seq(0, 1.00, len = 1000)
lambda_2 <- seq(0.5, 1.5, len = 1000)
lambda_2
lambda_start <- c(0.37, 0.94)
lambda_1 <- seq(0, 1.00, len = 200)
lambda_2 <- seq(0.5, 1.5, len = 200)
lambda_1 <- outer(lambda_1, rep(1, 200))
View(lambda_1)
lambda_start <- c(0.37, 0.94)
lambda_1 <- seq(0, 1.00, len = 200)
lambda_2 <- seq(0.5, 1.5, len = 200)
lambda_1 <- outer(lambda_1, rep(1, 200))
lambda_2 <- outer(lambda_2, rep(1,200))
lambda_matrix <- matrix(rep(0, times = 40000), nrow = 200, ncol = 200)
box_cox <- function(data, lambda, n){
#Create vector to store values for l of lambda
l_of_lambda <- rep(-100, times = length(lambda))
#For loop to calculate l of lambda
for(i in 1:length(lambda)){
#Check if lambda is equal to 0
if(lambda[i] != 0){
y <- (data^(lambda[i]) - 1)/lambda[i]
} else{
y <- log(data)
}
#Calculate mean of transformed x_1 values
y_bar <- mean(y)
#Calculate value for l of lambda function and store it in the vector
l_of_lambda[i] <- (-n/2)*log((1/n) * sum((y - y_bar)^2)) +
(lambda[i] - 1) * sum(log(data))
}
#Find the lambda value that corresponds to the max value of l of lambda
lambda_final <- lambda[which.max(l_of_lambda)]
return(lambda_final)
}
#Create vector of possible lambda values
lambda <- seq(from = -5.00, to = 5.00, by = 0.01)
#Let n = length of x_1 vector
n <- 10
#Create vector of x_1 values
x_1 <- c(1, 2, 3, 3, 4, 5, 6, 8, 9, 11)
#Find lambda value
lambda_final <- box_cox(x_1, lambda, n)
lambda_final
#Transform x_1 using this lambda value
transformed_x_1 <- (x_1^lambda_final - 1)/lambda_final
transformed_x_1 <- sort(transformed_x_1)
#Calculate the quantiles for the actual data
prob_levels <- ((1:n)-0.5)/n
#Calculate the theoretical normal quantiles
standard_normal_quantiles <- qnorm(prob_levels)
#Round the theoretical quantiles to 2 decimal places
standard_normal_quantiles <- round(standard_normal_quantiles,
digits = 2)
#Create matrix of values
qq_matrix <- as.data.frame(cbind(transformed_x_1, prob_levels,
standard_normal_quantiles))
#Print matrix
qq_matrix
#Output plot
ggplot(qq_matrix, aes(standard_normal_quantiles, transformed_x_1)) +
geom_point(size=3) +
geom_smooth(method='lm', se=F) +
xlab("Theoretical Quantiles") +
ylab("Ordered Data") +
ggtitle(TeX('Q-Q Plot for $x_1$')) +
theme.info
#Create vector of x_2 values
x_2 <- c(18.95, 19.00, 17.95, 15.54,
14.00, 12.95, 8.94, 7.49, 6.00, 3.99)
#Find lambda value
lambda_final <- box_cox(x_2, lambda, n)
lambda_final
#Transform x_2 using this lambda value
transformed_x_2 <- (x_2^lambda_final - 1)/lambda_final
transformed_x_2 <- sort(transformed_x_2)
#Calculate the quantiles for the actual data
prob_levels <- ((1:n)-0.5)/n
#Calculate the theoretical normal quantiles
standard_normal_quantiles <- qnorm(prob_levels)
#Round the theoretical quantiles to 2 decimal places
standard_normal_quantiles <- round(standard_normal_quantiles,
digits = 2)
#Create matrix of values
qq_matrix <- as.data.frame(cbind(transformed_x_2, prob_levels,
standard_normal_quantiles))
#Print matrix
qq_matrix
#Output plot
ggplot(qq_matrix, aes(standard_normal_quantiles, transformed_x_2)) +
geom_point(size=3) +
geom_smooth(method='lm', se=F) +
xlab("Theoretical Quantiles") +
ylab("Ordered Data") +
ggtitle(TeX('Q-Q Plot for $x_2$')) +
theme.info
lambda_start <- c(0.37, 0.94)
lambda_1 <- seq(0, 1.00, len = 200)
lambda_2 <- seq(0.5, 1.5, len = 200)
lambda_1 <- outer(lambda_1, rep(1, 200))
lambda_2 <- outer(lambda_2, rep(1,200))
lambda_matrix <- matrix(rep(0, times = 40000), nrow = 200, ncol = 200)
x <- cbind(x_1, x_2)
View(x)
View(lambda_2)
View(lambda_1)
X[1:200^2]
lambda_1[1:200^2]
X <- cbind(lambda_1[1:200^2], lambda_2[1:200^2])
View(X)
X <- cbind(lambda_1[1:n2], lambda_2[1:n2])
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(lambda_2, rep(1,ng))
X <- cbind(lambda_1[1:n2], lambda_2[1:n2])
lambda_matrix <- matrix(rep(0, times = 40000), nrow = 200, ncol = 200)
x <- cbind(x_1, x_2)
for(i in 1:200){
for(j in 1:200){
}
}
View(X)
View(lambda_2)
View(X)
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
X <- cbind(lambda_1[1:n2], lambda_2[1:n2])
lambda_matrix <- matrix(rep(0, times = 40000), nrow = 200, ncol = 200)
x <- cbind(x_1, x_2)
for(i in 1:200){
for(j in 1:200){
}
}
View(X)
View(X)
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
x <- cbind(x_1, x_2)
for(i in 1:nrow(lambda_matrix){
}
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
x <- cbind(x_1, x_2)
for(i in 1:nrow(lambda_matrix)){
}
lambda_matrix[1]
lambda_matrix[1,]
x[,1]
View(x)
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0.0001, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
x <- cbind(x_1, x_2)
for(i in 1:nrow(lambda_matrix)){
lambda_vals <- lambda_matrix[i, ]
transformed_x <- (x[,1]-1)/lambda_vals[1]
transformed_x <- cbind(transformed_x, (x[,1]-1)/lambda_vals[0])
}
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0.0001, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
x <- cbind(x_1, x_2)
for(i in 1:nrow(lambda_matrix)){
lambda_vals <- lambda_matrix[i, ]
transformed_x <- (x[,1]-1)/lambda_vals[1]
transformed_x <- cbind(transformed_x, (x[,2]-1)/lambda_vals[0])
}
View(transformed_x)
x[,2]
transformed_x <- (x[,1]-1)/0.5
transformed_x <- cbind(transformed_x, (x[,2]-1)/1.2)
View(transformed_x)
transformed_x <- cbind((x[,1]-1)/0.1, (x[,2]-1)/1.2)
View(transformed_x)
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0.0001, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
x <- cbind(x_1, x_2)
for(i in 1:nrow(lambda_matrix)){
lambda_vals <- lambda_matrix[i, ]
transformed_x <- cbind((x[,1]-1)/lambda_vals[1], (x[,2]-1)/lambda_vals[2])
}
View(transformed_x)
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0.0001, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
x <- cbind(x_1, x_2)
for(i in 1:nrow(lambda_matrix)){
lambda_vals <- lambda_matrix[i, ]
transformed_x <- cbind((x[,1]^(lambda_vals[1]) - 1)/lambda_vals[1], (x[,2]^(lambda_vals[2]) - 1)/lambda_vals[2])
S <- cov(transformed_x)
det_S <- det(S)
l_of_lambda_vec[i] <- (-n/2) * log(det_S) + (lambda_vals[1] - 1) * sum(log(x[,1])) + (lambda_vals[2] - 1) * sum(log(x[,2]))
}
#Find the lambda value that corresponds to the max value of l of lambda
lambda_vec_final <- lambda_matrix[which.max(l_of_lambda_vec)]
lambda_vec_final
lambda_start <- c(0.37, 0.94)
ng <- 200
n2 <- ng^2
lambda_1 <- seq(0.0001, 1.00, len = ng)
lambda_2 <- seq(0.5, 1.5, len = ng)
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
x <- cbind(x_1, x_2)
for(i in 1:nrow(lambda_matrix)){
lambda_vals <- lambda_matrix[i, ]
transformed_x <- cbind((x[,1]^(lambda_vals[1]) - 1)/lambda_vals[1], (x[,2]^(lambda_vals[2]) - 1)/lambda_vals[2])
S <- cov(transformed_x)
det_S <- det(S)
l_of_lambda_vec[i] <- (-n/2) * log(det_S) + (lambda_vals[1] - 1) * sum(log(x[,1])) + (lambda_vals[2] - 1) * sum(log(x[,2]))
}
#Find the lambda value that corresponds to the max value of l of lambda
lambda_vec_final <- lambda_matrix[which.max(l_of_lambda_vec),]
which.mac(l_of_lambda_vec)
which.max(l_of_lambda_vec)
lambda_matrix[196,]
lambda_matrix[196,][1]
#Length of sequence for lambda values
ng <- 200
#Size of lambda matrix
n2 <- ng^2
#Create lambda vectors
lambda_1 <- seq(0.0001, 2.00, len = ng)
lambda_2 <- seq(0.0001, 2.00, len = ng)
#Repeat lambda values
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
#Form grid of lambda values
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
#Create vector to store function values
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
#Create matrix of x values
x <- cbind(x_1, x_2)
#For loop for function
for(i in 1:nrow(lambda_matrix)){
#Get lambda values from grid
lambda_vals <- lambda_matrix[i, ]
#Compute transformed x matrix
transformed_x <- cbind((x[,1]^(lambda_vals[1]) - 1)/lambda_vals[1], (x[,2]^(lambda_vals[2]) - 1)/lambda_vals[2])
#Compute covariance of transformed x matrix
S <- cov(transformed_x)
#Compute determinant of covariance
det_S <- det(S)
#Calculate function value and store it in vector
l_of_lambda_vec[i] <- (-n/2) * log(det_S) +
(lambda_vals[1] - 1) * sum(log(x[,1])) +
(lambda_vals[2] - 1) * sum(log(x[,2]))
}
#Find the lambda vector that corresponds to the max value of l of lambda
lambda_vec_final <- lambda_matrix[which.max(l_of_lambda_vec),]
#Length of sequence for lambda values
ng <- 400
#Size of lambda matrix
n2 <- ng^2
#Create lambda vectors
lambda_1 <- seq(0.0001, 2.00, len = ng)
lambda_2 <- seq(0.0001, 2.00, len = ng)
#Repeat lambda values
lambda_1 <- outer(lambda_1, rep(1, ng))
lambda_2 <- outer(rep(1,ng), lambda_2)
#Form grid of lambda values
lambda_matrix <- cbind(lambda_1[1:n2], lambda_2[1:n2])
#Create vector to store function values
l_of_lambda_vec <- rep(0, times = nrow(lambda_matrix))
#Create matrix of x values
x <- cbind(x_1, x_2)
#For loop for function
for(i in 1:nrow(lambda_matrix)){
#Get lambda values from grid
lambda_vals <- lambda_matrix[i, ]
#Compute transformed x matrix
transformed_x <- cbind((x[,1]^(lambda_vals[1]) - 1)/lambda_vals[1], (x[,2]^(lambda_vals[2]) - 1)/lambda_vals[2])
#Compute covariance of transformed x matrix
S <- cov(transformed_x)
#Compute determinant of covariance
det_S <- det(S)
#Calculate function value and store it in vector
l_of_lambda_vec[i] <- (-n/2) * log(det_S) +
(lambda_vals[1] - 1) * sum(log(x[,1])) +
(lambda_vals[2] - 1) * sum(log(x[,2]))
}
#Find the lambda vector that corresponds to the max value of l of lambda
lambda_vec_final <- lambda_matrix[which.max(l_of_lambda_vec),]
